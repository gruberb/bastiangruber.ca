<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bastian Gruber</title>
  <subtitle></subtitle>
  <link href="https://bastiangruber.ca/feed.xml" rel="self"/>
  <link href="https://bastiangruber.ca/"/>
  
    <updated>2026-01-03T00:00:00Z</updated>
  
  <id>https://bastiangruber.ca</id>
  <author>
    <name>Bastian Gruber</name>
    <email>info@bastiangruber.ca</email>
  </author>
  
    
    <entry>
      <title>How I browse the web in 2026</title>
      <link href="https://bastiangruber.ca/posts/how-i-browse-the-web-in-2026/"/>
      <updated>2026-01-03T00:00:00Z</updated>
      <id>https://bastiangruber.ca/posts/how-i-browse-the-web-in-2026/</id>
      <content type="html">
        <![CDATA[
      <p>This blog post should serve as a time capsule for my future self. How was it like serving the Internet in 2026? What is my set up, my most visitied bookmarks, websites I frequently go to? Let's find out.</p>
<h3>Hardware excursion</h3>
<p>For the very first time, I cleanly separated my work (MacBook Pro M3 Pro) and my private digital life (Framework AMD 13&quot; with Arch + COSMIC). I deinstalled all work related apps and logins from my phone (iPhone 13 Pro Max). I use Firefox on all devices, Thunderbird on my Framework laptop (and use GMail via the browser on my work laptop). On my iPhone, I use the default Mail client. I also <a href="https://bastiangruber.ca/posts/mass-quitting-apple/">unplugged completely from Apple</a> and hope to get a <a href="https://tbot.substack.com/p/grapheneos-new-oem-partnership">GrapheneOS native Android phone soon</a>.</p>
<h3>My (Firefox) extensions</h3>
<ul>
<li><del><a href="https://addons.mozilla.org/en-US/firefox/addon/hide-youtube-shorts/">Hide shorts for Youtube</a></del> Using <a href="https://addons.mozilla.org/en-US/firefox/addon/youtube-enhancer-vc/">YouTube Enhancer</a> now for this.</li>
<li><del><a href="https://addons.mozilla.org/en-US/firefox/addon/istilldontcareaboutcookies/">I still don't care about cookies</a></del></li>
<li>Someone on lobste.rs pointed out <a href="https://addons.mozilla.org/en-US/firefox/addon/consent-o-matic/">Consent-O-Matic</a></li>
<li><a href="https://addons.mozilla.org/en-US/firefox/addon/ublock-origin/">uBlock Origin</a>
<ul>
<li>A commenter pointed out these are redundant if you use uBlock Origin (which has URL tracking protection and tracker blocking built-in):</li>
<li><del><a href="https://addons.mozilla.org/en-US/firefox/addon/sponsorblock/">SponsorBlock for YouTube - Skip Sponsorships</a></del></li>
<li><del><a href="https://addons.mozilla.org/en-US/firefox/addon/adblock-for-youtube/">AdBlocker for YouTube</a></del></li>
<li><del><a href="https://addons.mozilla.org/en-US/firefox/addon/clearurls/">ClearURLs</a></del></li>
<li><del><a href="https://addons.mozilla.org/en-US/firefox/addon/privacy-badger17/">Privacy Badger</a></del></li>
</ul>
</li>
<li><a href="https://addons.mozilla.org/en-US/firefox/addon/youtube-enhancer-vc/">YouTube Enhancer</a></li>
<li><a href="https://addons.mozilla.org/en-US/firefox/addon/are-na/">Are.na</a></li>
<li><a href="https://addons.mozilla.org/en-US/firefox/addon/bitwarden-password-manager/">Bitwarden Password Manager</a></li>
<li><a href="https://gitflic.ru/project/magnolia1234/bpc_uploads/blob/?file=bypass_paywalls_clean-latest.xpi&amp;branch=main">Bypass Paywalls Clean</a></li>
</ul>
<h4>Configuring uBlock Origin for maximum coverage</h4>
<p>Open uBlock Origin settings (click the extension icon → three gear icon) and go to <strong>Filter lists</strong>. Make sure these are enabled:</p>
<p><strong>Privacy section:</strong></p>
<ul>
<li>EasyPrivacy (replaces Privacy Badger)</li>
<li>AdGuard/uBO – URL Tracking Protection (replaces ClearURLs)</li>
</ul>
<p><strong>Ads section:</strong></p>
<ul>
<li>EasyList</li>
</ul>
<p>uBlock Origin's built-in filters (enabled by default) handle YouTube ads specifically—no extra configuration needed.</p>
<p>Click &quot;Update now&quot; at the top, then &quot;Apply changes&quot;.</p>
<h3>Web Services I use</h3>
<ul>
<li><a href="https://ticktick.com">TickTick</a> for ToDos</li>
<li><a href="https://www.ynab.com/">YNAB</a> for finances</li>
<li><a href="https://excalidraw.com/">Excalidraw</a> for diagrams</li>
<li><a href="https://www.youtube.com/">YouTube</a> for...so many things honestly. I disable my <del>browser</del> watch history so no video recommendations and rabbit holes for me, perfect!</li>
<li><a href="https://miniflux.app/">Miniflux - Self hosted</a> for my own RSS needs</li>
<li><a href="https://app.wakingup.com/">WakingUp</a> for meditation</li>
<li><a href="https://github.com/gruberb">GitHub</a> for my coding projects.</li>
</ul>
<h3>Go-to websites I often browse</h3>
<ol start="0">
<li><a href="https://isthelclcpoolopen.ca/">isthelclcpoolopen.ca</a> - A dashboard I created for our local community pool.</li>
<li><a href="https://www.theverge.com/">The Verge</a></li>
<li><a href="https://www.are.na">Are.na</a></li>
<li><a href="https://pinboard.in/popular/">Popular Pinboard posts</a></li>
<li><a href="https://lobste.rs/">Lobsters</a></li>
<li><a href="https://news.ycombinator.com/">HackerNews</a></li>
<li><a href="https://www.newsminimalist.com/">NewsMinimalist</a></li>
<li><a href="https://letterboxd.com/">Letterbox</a></li>
</ol>
<h3>Flow</h3>
<p>I often times open the browser mindlessly, click on the suggested shortcuts in Firefox of my last visited websites, and see what's new. Once a day or around 3 times a week, I check my RSS feed. I really enjoy going to the websites directly, and RSS seems to... clean and stripped down. But I also don't want to check 15 blogs manually every day, so it's good enough.</p>
<p>I save websites (articles really) to my <a href="https://www.are.na/bastian-foreach-me-com/channels">Are.na account</a> and promised myself to read it later. Which... I barely do. I started a TickTick list with an every day task to read at least 2 articles from my <a href="https://www.are.na/bastian-foreach-me-com/aha-coding">&quot;Aha! Coding&quot;</a> channel. And I want to read more papers and watch tutorials this year. It's always a nice attempt, and once work is heating up, I read up on so many things I need at that moment, that I don't have much time or energy left to read &quot;general purpose&quot; content. But every time I come across a new problem, I find a saved article months later which would have helped me - at least partly - with that. So I want to make a new attempt of being religious about reading tech articles again.</p>
<p><a href="https://news.ycombinator.com/">HackerNews</a> is still one of my most visited website. I barely read the comments anymore, maybe the first one. But it's a good hub to know what's generally going on in the wider industry. Same with <a href="https://lobste.rs/">Lobsters</a>, but I enjoy going through the comments there, even of posts I am not interested in. <a href="https://pinboard.in/popular/">Pinboard</a> is another one where I go through the popular saved articles, but don't use the service myself anymore.</p>
<p>For meditation and introspection, I enjoy <a href="https://app.wakingup.com/">WakingUp</a>. It's sometimes &quot;too far out there&quot;, but it's less cluttered than the other suppose-to-be meditation apps. And I still need some prompts or guidance, especially during a hectic day with work, family, hobbies and friends.</p>
<p>For my ToDos: I actually managed to have 0 ToDo apps during most of 2025. They always stress me out seeing all the open things in my life I currently can't make progress on. Work is manged separete, and life is happening so much at the moment with kids and family, that the top 3-5 priority tasks are always obvious. But I also realized I am missing out on cleaning out my (digital) life and experimenting with project ideas or blog posts. It's good to have a place to store them again. I start to use <a href="https://ticktick.com/">TickTick</a>. I wish OmniFocus, Things and TickTick would have a baby. But TickTick is the best multi-platform tool I found, and it's &quot;good enough&quot;. I really miss going nerdy in OmniFocus, and I miss the sheer beauty and simplicity of Things. But oh well. Can't have it all it seems.</p>
<p>I mange my finances for the past 15 years with <a href="https://www.ynab.com/">YNAB</a>. It is slowly not the best tool anymore, and I want to try <a href="https://www.monarch.com/">Monarch</a>, but their Canadian bank account support doesn't seem to be working reliably. But hey, they actually have a <a href="https://www.monarch.com/connection-status">dashboard</a> for it!</p>
<p>Coding projects still live in <a href="https://github.com">GitHub</a>, and it slowly time to self host my projects. I never really collaborate much on these projects, but just want to store them somewhere where I can run workers. I would miss the hosting static websites via GitHub pages, so I have to figure out how to do that.</p>
<p>A bigger part takes <a href="https://www.youtube.com/">YouTube</a>. I listen to DJ sets, follow a few channels and often times watch tutorials or talks on it. YouTube is I think the only service which I am very happy to pay money for. Now it's owned by Google and I am sure there are some shady things going on with pushing videos front and center. I disabled my watcb history, so I see a black blank page when I open the general website. <strong>I have three YouTube bookmarks</strong>:</p>
<ul>
<li>Subscription view</li>
<li>&quot;Watch it later&quot; playlist</li>
<li>My own &quot;Music&quot; playlist</li>
</ul>
<p>So I never browse YouTube mindlessly, and get no video recommendations (disabled also via one of the YouTube extensions).</p>
<hr>
<p>That's it - that's my setup. I use <a href="https://www.firefox.com/en-CA/features/sync/">Firefox Sync</a> to have my account stored not only on my laptop, and as soon I setup Firefox somehwere else, all my extensions and bookmarks are back. And I trust Mozilla with my data (I work there and can talk to the folks and they are all great :)).</p>
<p>I don't expect that I change this setup very much in 2027 - the web feels much slower to change, but I still want to have this noted down somewhere.</p>
<div class="info">
Discussion on Lobsters: <a href="https://lobste.rs/s/awxarg/how_i_browse_web_2026">https://lobste.rs/s/awxarg/how_i_browse_web_2026</a>
</div>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Mass quitting Apple</title>
      <link href="https://bastiangruber.ca/posts/mass-quitting-apple/"/>
      <updated>2025-12-22T00:00:00Z</updated>
      <id>https://bastiangruber.ca/posts/mass-quitting-apple/</id>
      <content type="html">
        <![CDATA[
      <p>There was a time, probably around 2012 (13 years ago) where I was hoping, wishing Apple would do better: <a href="https://en.wikipedia.org/wiki/MobileMe">MobileMe</a>. I was in university, and was writing for the German Macworld (<a href="https://www.macwelt.de/">Macwelt</a>) at the time. Dropbox was gaining more popularity, and the phone wars were just heating up. In my mind, it would have been a dream to have a proper, built-in cloud storage so I didn't have to manually sync my iMac and MacBook Air.</p>
<p>Be careful what you wish for. MobileMe ceased to exist. It was a horrible slog to use, and the best part of this service was my shiny @me.com E-Mail address which I still have. iCloud is now fast, and every service in Apple's ecosystem is bundled under one platform. Instead of being an open, configurable environment with APIs, we have another closed ecosystem with the only goal to keep you inside.</p>
<p>In a way that makes it intentionally hard to switch services or add other devices. I started a new job almost 2 years ago, and had to give up my company MacBook, and thought to myself: I need a backup machine. I ordered the Framework laptop and put Arch + <a href="https://system76.com/cosmic">COSMIC</a> on it. I use Firefox and Thunderbird, but had no way of integrating iCloud Drive in a nice way into my backup setup.</p>
<p>Few months down the line, and COSMIC entered the beta version. It is stable and fast. I fell deeper in love with my Framework laptop, which released a 2.8k 120Hz screen (finally), which I could just order and install myself (in less than 5 minutes).</p>
<p>I also fell in love with tinkering again, and felt constrained by the whole Apple ecosystem. To a point where every device but the Apple TV seems like a drag to use these days. So, time to break up with Apple (again).</p>
<h2>The problem with bundling</h2>
<p>Here's what I realized: Apple bundles four things that should be separate.</p>
<table>
<thead>
<tr>
<th>Layer</th>
<th>What it is</th>
<th>The Apple trap</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Identity</strong></td>
<td>How the world reaches you</td>
<td>Your @icloud.com address — they own it</td>
</tr>
<tr>
<td><strong>Data</strong></td>
<td>Files, photos, passwords, calendar</td>
<td>All in iCloud, all in one account</td>
</tr>
<tr>
<td><strong>Access</strong></td>
<td>How you connect securely</td>
<td>Their devices, their rules</td>
</tr>
<tr>
<td><strong>Recovery</strong></td>
<td>Getting it back when things break</td>
<td>&quot;Trust us&quot;</td>
</tr>
</tbody>
</table>
<p>One account suspension, one forgotten password, one &quot;suspicious activity&quot; flag — and all four collapse at once. Your email address, your photos, your passwords, your files. Gone.</p>
<p>I don't think Apple is going to lock me out. But I also don't want my digital life to depend on that assumption.</p>
<h2>My existing setup</h2>
<ul>
<li>I already owned a very small, dedicated server with OVH. But it was not very powerful (4GB of RAM, low storage, 100Mbit/s up/down, located in France — I live in Canada now, so slow pings). I configured NGINX, had domains pointed to the IP address, had existing SSL certificates with Let's Encrypt and other small services deployed on it.</li>
<li>I have 3-4 domains registered with GoDaddy.</li>
<li>I use it as my DNS server via <a href="https://adguard.com/en/adguard-home/overview.html">AdGuard Home</a>.</li>
</ul>
<h2>My goals</h2>
<p>I wanted a more powerful server, more RAM, bandwidth and also a faster ping. I wanted a built-in VPN, so certain services are forced to use a VPN connection or break by default. I wanted to host my own photos, files, calendars and contacts. I want an easy enough backup solution which runs by itself to a second, remote location.</p>
<h2>How I went about it</h2>
<p>The thought of setting up a whole self-hosted infrastructure seemed more than daunting. So many services to run and maintain, different installation scripts, docs which are probably outdated or don't exactly fit my particular needs etc.</p>
<p>But hey, we have a shiny new toy at our disposal: LLMs. It seemed to be perfect for this use case.</p>
<p>In my experience and usage, LLMs are vaguely helpful here. They can nail a solution, or lead you off stray if you are not careful in your planning phase. I was overwhelmed with transitioning and keeping existing files, and which services to use for calendars, contacts, photos, file sync, DNS, media handling, and legal torrenting for larger files and backups.</p>
<p>The LLM output was helpful in a way, where I could ask:</p>
<blockquote>
<p>&quot;These x,y,z are my needs. Tell me for File sync every possible self-hosting solution, and create a table with pros and cons. I want to be totally device independent, and it needs good Android, iOS, Linux and macOS apps or integration&quot;.</p>
</blockquote>
<p>This helped me get to know solutions I maybe wasn't aware of. I did this with every category to get a first overview what's out there.</p>
<p>Turns out, I knew every solution and was also aware of its pros and cons. But good to know anyway.</p>
<h2>What I chose</h2>
<table>
<thead>
<tr>
<th>Apple Service</th>
<th>Replacement</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>iCloud Keychain</td>
<td>Vaultwarden</td>
<td>Bitwarden-compatible, all the apps just work</td>
</tr>
<tr>
<td>iCloud Drive</td>
<td>Seafile</td>
<td>Fast, handles large files, decent mobile apps</td>
</tr>
<tr>
<td>Apple Photos</td>
<td>Immich</td>
<td>ML-powered search, face recognition. Impressive.</td>
</tr>
<tr>
<td>Calendar</td>
<td>Radicale</td>
<td>Simple CalDAV, native iOS/macOS support</td>
</tr>
<tr>
<td>Contacts</td>
<td>Radicale</td>
<td>CardDAV, same deal</td>
</tr>
<tr>
<td>Apple Music</td>
<td>Jellyfin</td>
<td>Media server for music and video</td>
</tr>
<tr>
<td>—</td>
<td>Transmission</td>
<td>Torrents, routed through VPN</td>
</tr>
<tr>
<td>—</td>
<td>WireGuard + Mullvad</td>
<td>VPN for specific services</td>
</tr>
<tr>
<td>—</td>
<td>AdGuard Home</td>
<td>DNS server</td>
</tr>
</tbody>
</table>
<p>For email, I went with <a href="https://migadu.com">Migadu</a>. Small Swiss company, straightforward pricing. I own the domain, they handle the mail. If they disappear, I point my MX records elsewhere and keep my address. That's the key thing — the address is mine now.</p>
<h2>How it went</h2>
<p>The real power doing this with LLMs was the guided step-by-step procedure without having to have hundreds of tabs open. I purchased a new dedicated server with OVH (this time: Intel Xeon, 64GB RAM, 4TB hard drive, located in Canada), and while I waited for the setup to be complete, I logged into my old server and printed every config to the terminal (<code>cat /path/to/config</code>) and copy pasted the whole terminal output. I pasted it in Claude and said: &quot;This is my setup, I want to re-create it on my new server.&quot;</p>
<p>It then just told me the <code>sudo apt install</code> commands and printed out the updated configs for each service, so I could just copy paste and move on. It even suggested to use a <code>tmux</code> session for the larger <code>rsync</code> operation from server A to B, so closing the <code>ssh</code> session wouldn't kill it. Obvious, but I am sure I would have closed it by accident, realized it, googled, had an &quot;Aha, of course tmux&quot; moment and looked for all the right commands on some random blog post.</p>
<blockquote>
<p>I wish LLMs would credit all their sources more. I love these blog posts, and using them subconsciously through a LLM feels just wrong.</p>
</blockquote>
<p>I really like that I can tell the LLM to guide me through it step by step, don't be overly expressive and basically just serve as a better helper so I don't have to type everything by hand.</p>
<p>Each service gets its own subdomain and NGINX acts as a reverse proxy. Setting this up was surprisingly straightforward once I understood the pattern.</p>
<h3>The NGINX reverse proxy pattern</h3>
<p>Here's what a typical service config looks like (this is for Vaultwarden):</p>
<pre class="language-nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span><br>    <span class="token directive"><span class="token keyword">listen</span> <span class="token number">443</span> ssl http2</span><span class="token punctuation">;</span><br>    <span class="token directive"><span class="token keyword">server_name</span> vault.MY_DOMAIN.ca</span><span class="token punctuation">;</span><br><br>    <span class="token directive"><span class="token keyword">ssl_certificate</span> /etc/letsencrypt/live/MY_DOMAIN.ca/fullchain.pem</span><span class="token punctuation">;</span><br>    <span class="token directive"><span class="token keyword">ssl_certificate_key</span> /etc/letsencrypt/live/MY_DOMAIN.ca/privkey.pem</span><span class="token punctuation">;</span><br><br>    <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span><br>        <span class="token directive"><span class="token keyword">proxy_pass</span> http://127.0.0.1:8080</span><span class="token punctuation">;</span><br>        <span class="token directive"><span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span></span><span class="token punctuation">;</span><br>        <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Real-IP <span class="token variable">$remote_addr</span></span><span class="token punctuation">;</span><br>        <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span></span><span class="token punctuation">;</span><br>        <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-Proto <span class="token variable">$scheme</span></span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>The service (in this case, Vaultwarden) runs on <code>localhost:8080</code>. NGINX listens on 443, terminates SSL, and forwards requests. Each service follows this same pattern, just different ports and subdomains.</p>
<h3>DNS setup</h3>
<p>For each service, I add an A record in GoDaddy:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>Value</th>
<th>TTL</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>vault</td>
<td><code>167.114.xxx.xxx</code></td>
<td>600</td>
</tr>
<tr>
<td>A</td>
<td>files</td>
<td><code>167.114.xxx.xxx</code></td>
<td>600</td>
</tr>
<tr>
<td>A</td>
<td>photos</td>
<td><code>167.114.xxx.xxx</code></td>
<td>600</td>
</tr>
</tbody>
</table>
<p>All subdomains point to the same server IP. NGINX looks at the <code>Host</code> header and routes to the right service. One wildcard Let's Encrypt certificate covers them all.</p>
<h3>Service highlights</h3>
<p><strong>Vaultwarden</strong> was probably the easiest. It's a single Docker container that implements the Bitwarden API. The official Bitwarden apps (iOS, Android, browser extensions) just work — you just point them to your own domain instead of <code>vault.bitwarden.com</code>.</p>
<p><strong>Seafile</strong> handles file sync. It's fast enough that I can edit a file on my desktop and see it update on my phone within seconds. The mobile apps are decent, though not as polished as iCloud Drive. The Linux client (<code>seaf-cli</code>) works great as a daemon.</p>
<p><strong>Immich</strong> is honestly mind-blowing for a self-hosted project. Face recognition, object detection, map view, all running on my own hardware. The mobile app has auto-upload and it just works. The only catch: the ML container uses about 8GB of RAM, but I have 64GB so who cares.</p>
<h2>The VPN routing trick</h2>
<p>I wanted Transmission to always go through Mullvad, but not everything else. Turns out you can do this with WireGuard and policy-based routing.</p>
<p>Transmission runs as a specific user (UID 103 on my system). I added a routing rule that sends all traffic from that UID through the WireGuard tunnel:</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">ip</span> rule <span class="token function">add</span> uidrange <span class="token number">103</span>-103 lookup <span class="token number">200</span> priority <span class="token number">99</span><br><span class="token function">ip</span> route <span class="token function">add</span> default dev wg-mullvad table <span class="token number">200</span></code></pre>
<p>Everything else goes direct. I broke my connection quite a few times before I had figured it out.</p>
<h2>Backups</h2>
<p>This is the part I'm most paranoid about, and I think rightly so.</p>
<p>3-2-1 rule: three copies, two media types, one offsite.</p>
<ol>
<li><strong>Live data</strong> on the server</li>
<li><strong>Encrypted daily backup</strong> to a Hetzner Storage Box (offsite, in Germany) using <a href="https://restic.net/">restic</a></li>
<li><strong>Weekly sync</strong> to an external drive at home</li>
</ol>
<p>Daily backups run at 4am via systemd timer. Databases (Immich PostgreSQL, Seafile MariaDB) get dumped to SQL first so the snapshots are consistent.</p>
<h3>How the automation works</h3>
<p>The backup is triggered by a systemd timer that runs daily:</p>
<pre class="language-ini"><code class="language-ini"><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">Unit</span><span class="token punctuation">]</span></span><br><span class="token key attr-name">Description</span><span class="token punctuation">=</span><span class="token value attr-value">Daily backup to Hetzner Storage Box</span><br><span class="token key attr-name">Documentation</span><span class="token punctuation">=</span><span class="token value attr-value">https://restic.readthedocs.io/</span><br><br><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">Timer</span><span class="token punctuation">]</span></span><br><span class="token key attr-name">OnCalendar</span><span class="token punctuation">=</span><span class="token value attr-value">daily</span><br><span class="token key attr-name">OnCalendar</span><span class="token punctuation">=</span><span class="token value attr-value">*-*-* 04:00:00</span><br><span class="token key attr-name">Persistent</span><span class="token punctuation">=</span><span class="token value attr-value">true</span><br><span class="token key attr-name">RandomizedDelaySec</span><span class="token punctuation">=</span><span class="token value attr-value">15min</span><br><br><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">Install</span><span class="token punctuation">]</span></span><br><span class="token key attr-name">WantedBy</span><span class="token punctuation">=</span><span class="token value attr-value">timers.target</span></code></pre>
<p>The timer calls a service that runs the backup script:</p>
<pre class="language-ini"><code class="language-ini"><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">Unit</span><span class="token punctuation">]</span></span><br><span class="token key attr-name">Description</span><span class="token punctuation">=</span><span class="token value attr-value">Backup to Hetzner Storage Box via Restic</span><br><span class="token key attr-name">After</span><span class="token punctuation">=</span><span class="token value attr-value">network-online.target</span><br><span class="token key attr-name">Wants</span><span class="token punctuation">=</span><span class="token value attr-value">network-online.target</span><br><br><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">Service</span><span class="token punctuation">]</span></span><br><span class="token key attr-name">Type</span><span class="token punctuation">=</span><span class="token value attr-value">oneshot</span><br><span class="token key attr-name">ExecStart</span><span class="token punctuation">=</span><span class="token value attr-value">/usr/local/bin/maple-backup.sh</span><br><span class="token key attr-name">User</span><span class="token punctuation">=</span><span class="token value attr-value">root</span><br><span class="token key attr-name">Environment</span><span class="token punctuation">=</span><span class="token value attr-value">"<span class="token inner-value">RESTIC_REPOSITORY=sftp:uxxxxxx@uxxxxxx.your-storagebox.de:23/maple-backups</span>"</span><br><span class="token key attr-name">Environment</span><span class="token punctuation">=</span><span class="token value attr-value">"<span class="token inner-value">RESTIC_PASSWORD_FILE=/root/.restic-password</span>"</span></code></pre>
<p>The actual backup script dumps databases, then uses restic to create encrypted snapshots:</p>
<pre class="language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><br><span class="token builtin class-name">set</span> <span class="token parameter variable">-euo</span> pipefail<br><br><span class="token comment"># Dump databases before backup</span><br><span class="token function">docker</span> <span class="token builtin class-name">exec</span> immich_postgres pg_dumpall <span class="token parameter variable">-U</span> postgres <span class="token operator">></span> /backup/immich-db.sql<br><span class="token function">docker</span> <span class="token builtin class-name">exec</span> seafile-mariadb mysqldump <span class="token parameter variable">-u</span> root -p<span class="token string">"<span class="token variable">$DB_PASSWORD</span>"</span> --all-databases <span class="token operator">></span> /backup/seafile-db.sql<br><br><span class="token comment"># Run restic backup</span><br>restic backup <span class="token punctuation">\</span><br>    /opt/docker/vaultwarden <span class="token punctuation">\</span><br>    /opt/docker/seafile <span class="token punctuation">\</span><br>    /opt/docker/immich <span class="token punctuation">\</span><br>    /backup <span class="token punctuation">\</span><br>    <span class="token parameter variable">--exclude</span><span class="token operator">=</span><span class="token string">'*.tmp'</span> <span class="token punctuation">\</span><br>    --exclude-caches<br><br><span class="token comment"># Cleanup old snapshots (keep last 7 daily, 4 weekly, 6 monthly)</span><br>restic forget --keep-daily <span class="token number">7</span> --keep-weekly <span class="token number">4</span> --keep-monthly <span class="token number">6</span> <span class="token parameter variable">--prune</span><br><br><span class="token builtin class-name">echo</span> <span class="token string">"Backup completed at <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span><span class="token variable">)</span></span>"</span></code></pre>
<p>The Hetzner Storage Box is accessed via SFTP. Restic handles the encryption, deduplication, and compression. If the server dies, I can restore everything from the Storage Box to a new machine.</p>
<h2>What it costs</h2>
<table>
<thead>
<tr>
<th>Item</th>
<th>Monthly (CAD)</th>
</tr>
</thead>
<tbody>
<tr>
<td>OVH dedicated server</td>
<td>$38</td>
</tr>
<tr>
<td>Mullvad VPN</td>
<td>$8</td>
</tr>
<tr>
<td>Migadu email</td>
<td>$2</td>
</tr>
<tr>
<td>Domain</td>
<td>$2</td>
</tr>
<tr>
<td>Hetzner Storage Box</td>
<td>$6</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td><strong>~$56</strong></td>
</tr>
</tbody>
</table>
<p>Compare that to iCloud+ 2TB ($13) + 1Password ($5) + Spotify ($11) + VPN ($8) = ~$37/month.</p>
<p>So yes, I'm paying about $19/month more. But I have a dedicated server with 64GB of RAM and 4TB of storage. I can run side projects on it. Experiments. Whatever I want.</p>
<h2>What I learned</h2>
<p>The technical setup wasn't that hard. NGINX configs are basically copy-paste once you get the pattern. Docker Compose makes services reproducible. Systemd timers are rock solid.</p>
<p>The hard part was the mental shift. With Apple, everything just worked — until it didn't, and then you had no control. Now I have full control — but I'm also responsible when things break.</p>
<p>I check the backup logs every week. I monitor disk space. I keep the system updated. It's maybe 30 minutes of maintenance per month. Totally worth it for the peace of mind.</p>
<p>The biggest win? <strong>I own my identity now.</strong> My email address is on my domain. My files are on my server. My passwords are in my vault. If any single service disappears tomorrow, I can move. That's the freedom I was looking for.</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Non-Negotiables</title>
      <link href="https://bastiangruber.ca/posts/non-negotiables/"/>
      <updated>2024-06-16T00:00:00Z</updated>
      <id>https://bastiangruber.ca/posts/non-negotiables/</id>
      <content type="html">
        <![CDATA[
      <p>I thought about &quot;What makes a &quot;good&quot; engineer&quot; for a long time, and probably will until my death bed. In the day to day, it's sometimes hard to figure out: Did I do a good job? For the technical aspect of my day to day work, I printed own my own &quot;Non Negotiables&quot; (inspired by <a href="https://www.youtube.com/watch?v=VMp0Ai-YnMk">The Bear</a>), and put it next to my desk on the wall. I aim to follow them.</p>
<p>Here they are:</p>
<h3>Understand the problem/feature to evaluate the possible solutions</h3>
<p>Can it be efficetively solved with existing things or require new code?</p>
<h3>Aim for simplicity</h3>
<p>Think about what is necessary and sufficient to solve the problem, make interfaces and interactions as simple as they can be, don’t write “clever” or confusing code unless absolutely necessary.</p>
<h3>Aim for elegance</h3>
<p>Code should be readable and look beautiful, APIs should be small and well defined.</p>
<h3>Aim for efficiency where possible</h3>
<p>Avoid too many layers of abstraction or algorithms or structures that don’t scale.</p>
<h3>Think about clear separation of policy and mechanism</h3>
<p>Aim for simple clean mechanisms that you can layer different policies on as needed.</p>
<h3>Think about extensibility</h3>
<p>What things would your solution preclude being done in the future, try to spot leaky abstractions.</p>
<h3>Think about failure scenarios and how to test for them and recover or fail as gracefully as possible.</h3>
<h3>Use useful comments to help future maintainers</h3>
<p>Including yourself!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Tour of a HTTP request in Rust</title>
      <link href="https://bastiangruber.ca/posts/tour-of-a-http-request-in-rust/"/>
      <updated>2024-06-16T00:00:00Z</updated>
      <id>https://bastiangruber.ca/posts/tour-of-a-http-request-in-rust/</id>
      <content type="html">
        <![CDATA[
      <div class="info">
This article is part of a chapter of <a href="https://www.manning.com/books/rust-web-development" target="_blank">Rust Web Development</a> which didn't make the cut to be in the book.
</div>
<hr>
<h4 class="tldr">TL;DR</h4>
<img src="https://github.com/gruberb/bastiangruber.ca/blob/main/src/images/tldr-rust.png?raw=true" />
<hr>
<p>When we talk about a web service, we, more often than not, mean deployed code which listens on a certain IP address and port and responds to HTTP messages. There are many steps involved for two parties to be able to communicate with each other. Application developers are mainly confronted with two pieces of this process: TCP and HTTP.</p>
<p>TCP is a protocol which two parties use to establish a connection. They follow a certain pattern (three-way-handshake) where they send and receive short messages to negotiate the connection details. After establishing this connection, you can receive and send HTTP messages to the other party. HTTP is a stateless protocol which demands a response for every request, and defines, besides other options, the size and format of the data it is sending.</p>
<p>There is a great advantage in knowing how exactly the communication with TCP works and how and where HTTP is added. Having this information can help you improve the performance of your server application and make it more secure. If, for some reason, you want to choose any other protocol than TCP or HTTP, you know where and how to replace it.</p>
<div class="sidecar">
<h5>TCP vs. UDP</h5>
<p>TCP is a connection-oriented protocol which starts creating a connection via a so-called three-way-handshake. It makes sure to send packets in the right order and tries to resend them if they failed to arrive at the other side. TCP headers are therefore larger (20 bytes) and the whole process slower than if you would use UDP.</p>
<p>UDP packet headers are smaller (8 bytes) and there is no formal connection creation included in the protocol. The order of the packets is not secured and if one message fails to arrive, there is no built-in retry.
</p>
<p>You would use UDP for application like stock quotes or streaming services, gaming servers or weather applications. You can resend data more often, and if you want to implement your own retry mechanism. Also, data is getting outdated faster and you might not care about every single packet arrive in the same order or at all. UDP can also be broadcasted to several hosts whereas TCP is always a single client-server connection.
</p>
<p>You use TCP when you want a reliable data transfer. For example, banking applications or in e-commerce, where you don’t want to lose sensitive information along the way or have to communicate the state between client and server.
</p>
</div>
<h2>Rust and the OSI model</h2>
<p>Web services are deployed on computers connected to the internet. These computers have IP addresses and open ports they listen to for new messages. Applications running on these machines are signaling interest on certain messages so they can process and answer these.</p>
<div class="sidecar">
<h5>OSI model</h5>
<p>The Open Systems Interconnection (OSI) model is a helpful tool to abstract the underlying technology involved in transmitting bytes from A to B away. Bytes sent from a server to a client go through the computer itself, over to different routers and the physical wire connecting to larger endpoints.</p>
<p>The OSI model helps to visualize the stages involved in sending the bytes, and groups the parts involved in the process in different layers. The layers described in the model are Physical (1), Data link (2), Network (3), Transport (4), Session (5), Presentation (6), Application (7).
</p>
</div>
<p>A message sent to a server has to go through multiple layers and geographically different locations for it to arrive. To get a better understanding of these different layers, the OSI model was created. It is a conceptual framework to standardize the communications.</p>
<p>As we can see in the following figure, a client can’t just send over data to a server. It needs to go through many different routers to find the right server. For it not to get lost, a user application and the kernel are adding several headers to it, so each layer of the communication process knows where to route it to.</p>
<img src="https://github.com/gruberb/bastiangruber.ca/blob/main/src/images/osi.png?raw=true" />
<p>A packet goes through these different layers, and almost all of them add an extra header on top so the next layer knows how to deal with the information. Your application adds a HTTP header on top of the data it wants to send, before the kernel adds the TCP, IP and Ethernet header.</p>
<p>The receiving server goes through the same process but in reverse. It has to dismantle each header until it can read the data inside of it.</p>
<img src="https://github.com/gruberb/bastiangruber.ca/blob/main/src/images/header.png?raw=true" />
<p>The added header sizes are standardized, so the operating system and the kernel know how many bytes they have to strip out until they can read the data. We can use this information now to get a better grasp on our data we receive.</p>
<p>In the OSI overview figure earlier, we see that the ethernet and IP header are pretty non-negotiable. But everything else is more in our control. We can choose UDP for example instead of TCP and can use our own protocol instead of using HTTP. We can, for example, have security reasons to implement our own protocol (with an own header size), so intruders who are reading our messages can’t make sense of them.</p>
<p>Where does Rust come into play? A web service has to support the following mechanism for it to be able to create connection, receiving messages and sending responses:</p>
<ul>
<li>Opening a connection to another client</li>
<li>Support the different layers (TCP and HTTP)</li>
<li>Hold connections</li>
<li>Parse receiving messages</li>
<li>Send proper HTTP messages back</li>
</ul>
<p>Many other programming languages include a rich standard library to create these HTTP servers. Rust is however a little bit different. Being a Systems Programming Language, Rust wants to be as small as possible and also functioning well on micro controllers for example who don’t always want to communicate via HTTP with their peers.</p>
<p>Therefore, Rust decided just to include a basic understanding of TCP in the standard library, and no build-in support for HTTP. The blue parts (TCP/IP) are included in the Rust standard library. If you want to create web server which supports HTTP, you have to create your own. Luckily, this is a common scenario, so the community already built some battle-tested web server implementations in the past. The crate hyper for example is widely used as a http server.</p>
<div class="sidecar">
<h5>Rust crates</h5>
<p>External libraries or packages are called “crates” in Rust. They are hosted on a website called crates.io and will be retrieved once a Rust project compiles. You can add crates to a Rust project in the Cargo.toml file, and after using the cargo build or cargo run command on the terminal, the newly added crates will be downloaded and added to your local project.</p>
</div>
<p>There are also crates for web frameworks, which include all the layers beneath them (HTTP, TCP etc.) and offer all the modern ergonomics like parsing URL query parameter, reading and returning JSON and so on.</p>
<img src="https://github.com/gruberb/bastiangruber.ca/blob/main/src/images/figure_14.png?raw=true" />
<p>This also gives you a greater choice: If you just want a minimal functioning application server without much bloat doing one thing, you can create the few functions you need by hand and have a lightweight solution afterwards.</p>
<p>If you are coming from Go, NodeJS or Java, this means a shift in perspective. You probably have to look for a library which supports your needs from the start instead of going a few more miles without thinking about help from the community.</p>
<p>In addition to HTTP, you also need to make sure the connection between client and server is secure. This is handled via TLS (Transport Layer Security), a successor of SSL. Rust also hasn’t built-in TLS support, but there exist a few packages which support you in enabling TLS in your application.</p>
<h2>Opening a connection</h2>
<p>We look at an example where a browser application is sending a HTTP request to our web service which is written in Rust. We will dive shortly into how exactly the bytes arrive at the kernel, and how our Rust application is getting the bytes delivered into the running application. Note that this is all abstracted away through libraries, but you can later on choose not to use such library and implement something via the Rust core library itself.</p>
<p>In addition, it is helpful to know or at least heart about it once how exactly the flow of bytes in a web service works, so you can spot bugs, bottlenecks and other misconfigurations later on in your running application.</p>
<p>When the client sends a HTTP request, the kernel is wrapping the data in a package with a HTTP and TCP header attached to it. It arrives on our server at the so called NIC (network interface card). The client first has to establish a TCP connection to our server. Once done, our kernel opened a socket to which is listening to this address for incoming messages.</p>
<p>If you want to dig deeper into the kernel side of networking, I highly recommend <a href="https://beej.us/guide/bgnet/html/" target="_blank">Beej's Guide to Network Programming</a>.</p>
<img src="https://github.com/gruberb/bastiangruber.ca/blob/main/src/images/kernel.png?raw=true"/>
<p>When we run a web server in Rust, we also have a socket to the operating system side where we can listen to incoming messages. The kernel’s job is to copy the data from the incoming TCP message onto our internal socket and notifies us when new data arrived.</p>
<p>In detail, the kernel reads the incoming messages and figures out which TCP connection (IP address and port) it is associated with, looks up the corresponding socket and copies the data to a receive buffer.</p>
<p>It notifies the process which is listening to new data to this socket and copies the data to a new buffer once the process is signaling interest. It copies the data from the receive buffer into the read buffer so that your server application can get the bytes out of the kernel into your program.</p>
<div class="sidecar">
<h5>Forming full messages out of a stream</h5>
<p>When a client and server connect via TCP, they send data over a physical wire in a so-called stream. This data has no clear beginning and end. Once the connection is open, you send data and the kernel decides when the buffer is full and sends data out to the client and vice-versa. To be able to tell when “a full” message arrived, we need a protocol on top of TCP to tell us about the beginning, the structure and end of a message and conversation. In most cases, this protocol is HTTP.</p>
</div>
<p>We learned earlier that Rust supports TCP right out of the box. Therefore, we can create, open and listen to a TCP socket within Rust. Once we receive a message, we can also answer back on the same socket. We can basically send any text back to the socket, we just have to be aware that the other side can interpret what we are sending.</p>
<p>Let’s open a socket, so the kernel knows where to forward incoming requests to. Each socket has to know the protocol being used (TCP in our case), the IP address and the port. In Rust, the TcpListener is handling the job for us, and we can use bind to tell the kernel the address and port we are listening to.</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>net<span class="token punctuation">::</span></span><span class="token class-name">TcpListener</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> listener <span class="token operator">=</span> <span class="token class-name">TcpListener</span><span class="token punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>   	<span class="token keyword">for</span> stream <span class="token keyword">in</span> listener<span class="token punctuation">.</span><span class="token function">incoming</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> stream <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"stream accepted {:?}"</span><span class="token punctuation">,</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>If you use <code>cargo run</code> to start the server, open a browser and navigate to <code>localhost:8080</code>, you see that we print something like this:</p>
<pre class="language-bash"><code class="language-bash">stream accepted TcpStream <span class="token punctuation">{</span> addr: <span class="token number">127.0</span>.0.1:8080, peer: <span class="token number">127.0</span>.0.1:56931, fd: <span class="token number">4</span> <span class="token punctuation">}</span></code></pre>
<p>This is a step in the right direction. But why don’t we see any data or HTTP headers? It’s because we receive a stream and print it on the console. We actually have to read the content from the stream.</p>
<div class="sidecar">
<h5>Possible failure when starting a server</h5>
<p>Connecting to a port and establishing a connection can fail for many reasons. Therefore both the TcpListener and the stream of the type TcpStream will return a Result<T,E>. In our example we assume everything works correctly, but in a production environment, the port you are choosing can already be busy listening to another application. Once opened, the incoming stream is actually an attempt of a connection, which can fail due to buffer limitations for example. </p>
</div>
<p>When reading from the stream like that, the baseline we expect is UTF8 encoded text. At this point, the kernel already stripped away the TCP header and all we have left is the data encapsulated in it. This can either be HTTP headers + data or some other headers attached to the data.</p>
<p>Parsing our stream content, we should see the headers and also the data in plain text, and it is on us to strip away the headers to get to the real data of the message. Headers however play an important role: They help us interpret the data we receive.</p>
<p>There are many <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">different HTTP headers</a>, and the server is in charge to interpret them in the right way and work with them.</p>
<p>When using a web framework later on, all the details are abstracted away. However it is vital to understand the flow how information arrives at your application so later on, you can choose asynchronous strategies, your own protocol and where to look for optimizations.</p>
<h2>Adding HTTP</h2>
<p>The <code>TcpListener</code> gave us a stream, which we need to read and interpret. We have to somehow take this stream and read what’s in it. For this, we need a few components. First, we need to create a new function which takes an incoming stream and writes the bytes back to a local buffer. From there we can parse the data accordingly and send back an answer.</p>
<p>We add a helper function which does exactly that for us.</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">handle_stream</span><span class="token punctuation">(</span><span class="token keyword">mut</span> stream<span class="token punctuation">:</span> <span class="token class-name">TcpStream</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> buffer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    stream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> buffer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Request: {}"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from_utf8_lossy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>All we have to do is to call this function in our iterator.</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>net<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">TcpListener</span><span class="token punctuation">,</span> <span class="token class-name">TcpStream</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>io<span class="token punctuation">::</span>prelude<span class="token punctuation">::</span></span><span class="token operator">*</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>	<span class="token keyword">let</span> listener <span class="token operator">=</span> <span class="token class-name">TcpListener</span><span class="token punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>	<span class="token keyword">for</span> stream <span class="token keyword">in</span> listener<span class="token punctuation">.</span><span class="token function">incoming</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>	    <span class="token keyword">let</span> stream <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>	    <span class="token function">handle_stream</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span><br>	<span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>After starting the application again with cargo run, you can open a new browser window and navigate to the website <code>localhost:8080</code> and see what your application is printing onto the console.</p>
<p>It will vary with your browser of choice, but the current version of Safari will send multiple requests which look like the following:</p>
<pre class="language-bash"><code class="language-bash">GET / HTTP/1.1<br>Host: localhost:8080<br>Upgrade-Insecure-Requests: <span class="token number">1</span><br>Accept: text/html,application/xhtml+xml,application/xml<span class="token punctuation">;</span><span class="token assign-left variable">q</span><span class="token operator">=</span><span class="token number">0.9</span>,*/*<span class="token punctuation">;</span><span class="token assign-left variable">q</span><span class="token operator">=</span><span class="token number">0.8</span><br>User-Agent: Mozilla/5.0 <span class="token punctuation">(</span>Macintosh<span class="token punctuation">;</span> Intel Mac OS X 10_15_7<span class="token punctuation">)</span> AppleWebKit/605.1.15 <span class="token punctuation">(</span>KHTML, like Gecko<span class="token punctuation">)</span> Version/14.0 Safari/605.1.15<br>Accept-Language: en-us</code></pre>
<p>It includes:</p>
<ul>
<li><code>GET</code>: The HTTP method</li>
<li><code>/</code>: The Path on the server</li>
<li><code>HTTP/1.1</code>: The version of the HTTP protocol</li>
<li><code>HOST</code>: The host/domain of the server we want to request data from</li>
<li><code>Accept-Language</code>: Which human language we prefer and understand</li>
</ul>
<div class="sidecar">
<h5>Development workflow</h5>
<p>You can see based on this simple example that developing web services with Rust has a caveat. You have to stop and recompile your binary before you can test your code again. Since we have a very strict compiler, this can take sometimes longer than with other languages.</p>
<p>However, have in mind that you can install extensions for VIM or your IDE to run a code analyzer while you write it. This will highlight errors before you start an application again with cargo run. Since undefined behavior is almost impossible in Rust, you save countless hours afterwards compared to other languages</p>
</div>
<p>Instead of just printing out the stream, we can start to look at the HTTP specification, store the content in an array and iterate over it line by line, and create a HTTP struct out of it. This work is not trivial since we need to check the length of the message from the HTTP header and build the full message ourselves.</p>
<p>Thankfully there are already crates published in the Rust ecosystem which help you with this task. So, deploying a http server in production is much less work than we do here by hand.</p>
<div class="sidecar">
<h5>Why do we see a full HTTP message?</h5>
<p>We learned that bytes arrive in a stream with no clear beginning or end. The application layer protocol (HTTP) is responsible for structuring our byte stream. Why, however, are we seeing the HTTP request than as a full message with a beginning and end? Shouldn’t messages overlap or have missing information when getting pulled out of the stream?</p>
<p>We are just lucky. Since we have a simple application with just a few requests at once, the kernel buffer is just full enough to empty out and hand over the complete HTTP message. We can’t rely on that however in a production  ready application.</p>
</div>
<p>After you opened your browser and navigated to localhost:8080, you saw an error page. That’s because we don’t return an answer yet, which the HTTP protocol requests we do. To solve this problem, we can write onto the stream and send bytes back to the client.</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">handle_stream</span><span class="token punctuation">(</span><span class="token keyword">mut</span> stream<span class="token punctuation">:</span> <span class="token class-name">TcpStream</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> buffer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    stream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> buffer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from_utf8_lossy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">let</span> response <span class="token operator">=</span> <span class="token string">"HTTP/1.1 200 OK\r\n\r\n"</span><span class="token punctuation">;</span><br>    stream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    stream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>When you open your browser now and navigate to localhost:8080, you will get a blank page instead of an error. We successfully communicated via HTTP to another application in just a few lines of code.</p>
<hr>
<div class="info">
This article is part of a chapter of <a href="https://www.manning.com/books/rust-web-development" target="_blank">Rust Web Development</a> which didn't make the cut to be in the book.
</div>

    ]]>
      </content>
    </entry>
  
</feed>
